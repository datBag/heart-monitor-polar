<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Heart Rate Monitor</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { 
      margin: 0; 
      padding: 0;
      overscroll-behavior: none;
    }
    * {
      -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const Bluetooth = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="m7 7 10 10-5 5V2l5 5L7 17"/>
      </svg>
    );

    const Volume2 = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M11 5 6 9H2v6h4l5 4V5zM19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/>
      </svg>
    );

    const VolumeX = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M11 5 6 9H2v6h4l5 4V5zM23 9l-6 6M17 9l6 6"/>
      </svg>
    );

    function HeartRateMonitor() {
      const [connected, setConnected] = useState(false);
      const [heartRate, setHeartRate] = useState(0);
      const [history, setHistory] = useState([]);
      const [avgHR, setAvgHR] = useState(0);
      const [minHR, setMinHR] = useState(0);
      const [maxHR, setMaxHR] = useState(0);
      const [soundEnabled, setSoundEnabled] = useState(true);
      
      const canvasRef = useRef(null);
      const deviceRef = useRef(null);
      const characteristicRef = useRef(null);
      const audioContextRef = useRef(null);
      const animationRef = useRef(null);
      const trailPointsRef = useRef([]);
      const lastBeepTimeRef = useRef(Date.now());
      const beepAnimationFrameRef = useRef(null);
      const scrollXRef = useRef(0);

      useEffect(() => {
        return () => {
          if (audioContextRef.current) {
            audioContextRef.current.close();
          }
          if (beepAnimationFrameRef.current) {
            cancelAnimationFrame(beepAnimationFrameRef.current);
          }
        };
      }, []);

      const playBeep = () => {
        if (!soundEnabled) return;

        try {
          if (!audioContextRef.current) {
            audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
          }

          const ctx = audioContextRef.current;
          if (ctx.state === 'suspended') {
            ctx.resume();
          }

          const now = ctx.currentTime;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          
          osc.connect(gain);
          gain.connect(ctx.destination);
          
          osc.frequency.value = 800;
          osc.type = 'square';
          
          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(0.3, now + 0.002);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.025);
          
          osc.start(now);
          osc.stop(now + 0.025);
          
          lastBeepTimeRef.current = Date.now();
          
        } catch (e) {
          console.error('Audio error:', e);
        }
      };

      useEffect(() => {
        if (!connected || heartRate === 0 || !soundEnabled) {
          if (beepAnimationFrameRef.current) {
            cancelAnimationFrame(beepAnimationFrameRef.current);
            beepAnimationFrameRef.current = null;
          }
          return;
        }

        const beepLoop = () => {
          const now = Date.now();
          const timeSinceLastBeat = now - lastBeepTimeRef.current;
          const beatInterval = 60000 / heartRate;
          
          if (timeSinceLastBeat >= beatInterval) {
            playBeep();
          }
          
          beepAnimationFrameRef.current = requestAnimationFrame(beepLoop);
        };

        beepLoop();

        return () => {
          if (beepAnimationFrameRef.current) {
            cancelAnimationFrame(beepAnimationFrameRef.current);
          }
        };
      }, [heartRate, connected, soundEnabled]);

      const connectToDevice = async () => {
        try {
          if (!navigator.bluetooth) {
            alert('Web Bluetooth wird nicht unterstützt! Bitte Chrome oder Edge verwenden.');
            return;
          }

          const device = await navigator.bluetooth.requestDevice({
            filters: [{ services: ['heart_rate'] }],
            optionalServices: ['heart_rate']
          });

          deviceRef.current = device;
          
          device.addEventListener('gattserverdisconnected', () => {
            setConnected(false);
            setHeartRate(0);
            setHistory([]);
            trailPointsRef.current = [];
          });

          const server = await device.gatt.connect();
          const service = await server.getPrimaryService('heart_rate');
          const characteristic = await service.getCharacteristic('heart_rate_measurement');
          
          characteristicRef.current = characteristic;
          
          await characteristic.startNotifications();
          characteristic.addEventListener('characteristicvaluechanged', handleHeartRateChange);
          
          setConnected(true);
          lastBeepTimeRef.current = Date.now();
        } catch (error) {
          console.error('Verbindungsfehler:', error);
          alert('Verbindung fehlgeschlagen: ' + error.message);
        }
      };

      const handleHeartRateChange = (event) => {
        const value = event.target.value;
        const flags = value.getUint8(0);
        let hr;
        
        if ((flags & 0x01) === 0) {
          hr = value.getUint8(1);
        } else {
          hr = value.getUint16(1, true);
        }
        
        setHeartRate(hr);
        
        setHistory(prev => {
          const newHistory = [...prev, hr].slice(-60);
          const sum = newHistory.reduce((a, b) => a + b, 0);
          const avg = Math.round(sum / newHistory.length);
          const min = Math.min(...newHistory);
          const max = Math.max(...newHistory);
          
          setAvgHR(avg);
          setMinHR(min);
          setMaxHR(max);
          
          return newHistory;
        });
      };

      const getPulseHeight = (timeSinceLastBeat, beatInterval) => {
        if (beatInterval === 0) return 0;
        
        const phase = timeSinceLastBeat / beatInterval;
        
        if (phase < 0.02) {
          const t = phase / 0.02;
          return -0.2 * Math.sin(t * Math.PI);
        } else if (phase < 0.1) {
          const t = (phase - 0.02) / 0.08;
          return Math.sin(t * Math.PI) * 1.2;
        } else if (phase < 0.15) {
          const t = (phase - 0.1) / 0.05;
          return -0.3 * Math.sin(t * Math.PI);
        } else if (phase < 0.25) {
          const t = (phase - 0.15) / 0.1;
          return 0.15 * Math.sin(t * Math.PI);
        } else {
          return 0;
        }
      };

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerY = height / 2;

        const animate = () => {
          // Dunkler Hintergrund mit leichtem Gradient
          const gradient = ctx.createLinearGradient(0, 0, 0, height);
          gradient.addColorStop(0, '#0a0e1a');
          gradient.addColorStop(1, '#0f1419');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, width, height);

          // Subtiles Gitter
          ctx.strokeStyle = 'rgba(100, 150, 255, 0.08)';
          ctx.lineWidth = 0.5;
          
          for (let x = 0; x < width; x += 40) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
          }
          
          for (let y = 0; y < height; y += 40) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
          }

          // Mittellinie
          ctx.strokeStyle = 'rgba(100, 150, 255, 0.15)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(0, centerY);
          ctx.lineTo(width, centerY);
          ctx.stroke();

          scrollXRef.current += 4;
          
          if (scrollXRef.current > width) {
            scrollXRef.current = 0;
            trailPointsRef.current = [];
          }

          const now = Date.now();
          const timeSinceLastBeat = now - lastBeepTimeRef.current;
          const beatInterval = heartRate > 0 ? (60000 / heartRate) : 0;
          
          const pulseHeight = getPulseHeight(timeSinceLastBeat, beatInterval);
          const y = centerY - pulseHeight * 100;

          trailPointsRef.current.push({ x: scrollXRef.current, y: y });
          
          const maxTrailLength = Math.floor(width / 4);
          while (trailPointsRef.current.length > maxTrailLength) {
            trailPointsRef.current.shift();
          }

          // EKG-Linie mit Glow-Effekt
          if (trailPointsRef.current.length > 1) {
            for (let i = 0; i < trailPointsRef.current.length - 1; i++) {
              const point = trailPointsRef.current[i];
              const nextPoint = trailPointsRef.current[i + 1];
              
              const distanceFromCurrent = scrollXRef.current - point.x;
              const maxDistance = width / 4;
              const opacity = Math.max(0, 1 - (distanceFromCurrent / maxDistance));
              
              // Äußerer Glow
              ctx.strokeStyle = `rgba(59, 130, 246, ${opacity * 0.3})`;
              ctx.lineWidth = 6;
              ctx.shadowBlur = 15;
              ctx.shadowColor = `rgba(59, 130, 246, ${opacity * 0.5})`;
              
              ctx.beginPath();
              ctx.moveTo(point.x, point.y);
              ctx.lineTo(nextPoint.x, nextPoint.y);
              ctx.stroke();
              
              // Innere Linie
              ctx.strokeStyle = `rgba(96, 165, 250, ${opacity})`;
              ctx.lineWidth = 3;
              ctx.shadowBlur = 10;
              ctx.shadowColor = `rgba(96, 165, 250, ${opacity})`;
              
              ctx.beginPath();
              ctx.moveTo(point.x, point.y);
              ctx.lineTo(nextPoint.x, nextPoint.y);
              ctx.stroke();
            }
          }

          // Aktueller Punkt
          ctx.shadowBlur = 25;
          ctx.shadowColor = '#60a5fa';
          ctx.fillStyle = '#60a5fa';
          
          ctx.beginPath();
          ctx.arc(scrollXRef.current, y, 6, 0, Math.PI * 2);
          ctx.fill();
          
          // Innerer heller Kern
          ctx.shadowBlur = 15;
          ctx.fillStyle = '#93c5fd';
          ctx.beginPath();
          ctx.arc(scrollXRef.current, y, 3, 0, Math.PI * 2);
          ctx.fill();

          animationRef.current = requestAnimationFrame(animate);
        };

        animate();

        return () => {
          if (animationRef.current) {
            cancelAnimationFrame(animationRef.current);
          }
        };
      }, [heartRate, connected]);

      const disconnect = () => {
        if (beepAnimationFrameRef.current) {
          cancelAnimationFrame(beepAnimationFrameRef.current);
        }
        
        if (characteristicRef.current) {
          try {
            characteristicRef.current.stopNotifications();
          } catch (e) {
            console.error('Stop notifications error:', e);
          }
        }
        
        if (deviceRef.current && deviceRef.current.gatt.connected) {
          deviceRef.current.gatt.disconnect();
        }
        
        setConnected(false);
        setHeartRate(0);
        setHistory([]);
        setAvgHR(0);
        setMinHR(0);
        setMaxHR(0);
        trailPointsRef.current = [];
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-white p-3 flex flex-col">
          {/* Header Buttons */}
          <div className="flex gap-2 mb-4">
            <button
              onClick={() => setSoundEnabled(!soundEnabled)}
              className="flex-1 flex items-center justify-center gap-2 bg-slate-800/50 backdrop-blur-sm border border-slate-700/50 px-4 py-3 rounded-xl active:scale-95 transition-transform shadow-lg"
            >
              {soundEnabled ? (
                <Volume2 className="w-5 h-5 text-blue-400" />
              ) : (
                <VolumeX className="w-5 h-5 text-slate-500" />
              )}
              <span className="text-sm font-medium">{soundEnabled ? "Sound On" : "Sound Off"}</span>
            </button>
            
            {!connected ? (
              <button
                onClick={connectToDevice}
                className="flex-1 flex items-center justify-center gap-2 bg-blue-600 hover:bg-blue-700 px-4 py-3 rounded-xl active:scale-95 transition-all shadow-lg shadow-blue-500/30"
              >
                <Bluetooth className="w-5 h-5" />
                <span className="text-sm font-semibold">Connect</span>
              </button>
            ) : (
              <button
                onClick={disconnect}
                className="flex-1 flex items-center justify-center gap-2 bg-red-600 hover:bg-red-700 px-4 py-3 rounded-xl active:scale-95 transition-all shadow-lg shadow-red-500/30"
              >
                <span className="text-sm font-semibold">Disconnect</span>
              </button>
            )}
          </div>

          {/* Heart Rate Display */}
          <div className="bg-gradient-to-br from-slate-800/80 to-slate-900/80 backdrop-blur-sm border border-slate-700/50 rounded-2xl p-6 mb-4 shadow-2xl">
            <div className="text-center">
              <div className="text-8xl font-bold tabular-nums bg-gradient-to-r from-blue-400 to-blue-600 bg-clip-text text-transparent mb-2">
                {heartRate || '--'}
              </div>
              <div className="text-2xl font-medium text-slate-400">BPM</div>
              {connected && (
                <div className="mt-2 flex items-center justify-center gap-2">
                  <div className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
                  <span className="text-xs text-green-400 font-medium">LIVE</span>
                </div>
              )}
            </div>
          </div>

          {/* EKG Display */}
          <div className="bg-gradient-to-br from-slate-800/80 to-slate-900/80 backdrop-blur-sm border border-slate-700/50 rounded-2xl p-4 mb-4 shadow-2xl flex-1 min-h-[300px] flex flex-col">
            <div className="text-xs font-medium text-slate-400 mb-2 uppercase tracking-wider">ECG Monitor</div>
            <div className="flex-1 rounded-xl overflow-hidden">
              <canvas
                ref={canvasRef}
                width={1600}
                height={600}
                className="w-full h-full"
              />
            </div>
          </div>

          {/* Stats */}
          <div className="grid grid-cols-3 gap-3">
            <div className="bg-gradient-to-br from-slate-800/60 to-slate-900/60 backdrop-blur-sm border border-slate-700/50 rounded-xl p-4 text-center shadow-lg">
              <div className="text-xs text-slate-400 mb-1 uppercase tracking-wide">Avg</div>
              <div className="text-3xl font-bold text-blue-400">{avgHR || '--'}</div>
            </div>
            <div className="bg-gradient-to-br from-slate-800/60 to-slate-900/60 backdrop-blur-sm border border-slate-700/50 rounded-xl p-4 text-center shadow-lg">
              <div className="text-xs text-slate-400 mb-1 uppercase tracking-wide">Min</div>
              <div className="text-3xl font-bold text-cyan-400">{minHR || '--'}</div>
            </div>
            <div className="bg-gradient-to-br from-slate-800/60 to-slate-900/60 backdrop-blur-sm border border-slate-700/50 rounded-xl p-4 text-center shadow-lg">
              <div className="text-xs text-slate-400 mb-1 uppercase tracking-wide">Max</div>
              <div className="text-3xl font-bold text-purple-400">{maxHR || '--'}</div>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.render(<HeartRateMonitor />, document.getElementById('root'));
  </script>
</body>
</html>
