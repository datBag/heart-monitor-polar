<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Heart Rate Monitor</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { 
      margin: 0; 
      padding: 0;
      overscroll-behavior: none;
    }
    * {
      -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const Bluetooth = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="m7 7 10 10-5 5V2l5 5L7 17"/>
      </svg>
    );

    const Volume2 = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M11 5 6 9H2v6h4l5 4V5zM19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/>
      </svg>
    );

    const VolumeX = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M11 5 6 9H2v6h4l5 4V5zM23 9l-6 6M17 9l6 6"/>
      </svg>
    );

    function HeartRateMonitor() {
      const [connected, setConnected] = useState(false);
      const [heartRate, setHeartRate] = useState(0);
      const [history, setHistory] = useState([]);
      const [avgHR, setAvgHR] = useState(0);
      const [minHR, setMinHR] = useState(0);
      const [maxHR, setMaxHR] = useState(0);
      const [soundEnabled, setSoundEnabled] = useState(true);
      
      const canvasRef = useRef(null);
      const deviceRef = useRef(null);
      const characteristicRef = useRef(null);
      const audioContextRef = useRef(null);
      const animationRef = useRef(null);
      const trailPointsRef = useRef([]);
      const lastBeepTimeRef = useRef(Date.now());
      const beepAnimationFrameRef = useRef(null);
      const scrollXRef = useRef(0);

      useEffect(() => {
        return () => {
          if (audioContextRef.current) {
            audioContextRef.current.close();
          }
          if (beepAnimationFrameRef.current) {
            cancelAnimationFrame(beepAnimationFrameRef.current);
          }
        };
      }, []);

      const playBeep = () => {
        if (!soundEnabled) return;

        try {
          if (!audioContextRef.current) {
            audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
          }

          const ctx = audioContextRef.current;
          if (ctx.state === 'suspended') {
            ctx.resume();
          }

          const now = ctx.currentTime;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          
          osc.connect(gain);
          gain.connect(ctx.destination);
          
          osc.frequency.value = 800;
          osc.type = 'square';
          
          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(0.3, now + 0.002);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.025);
          
          osc.start(now);
          osc.stop(now + 0.025);
          
          lastBeepTimeRef.current = Date.now();
          
        } catch (e) {
          console.error('Audio error:', e);
        }
      };

      useEffect(() => {
        if (!connected || heartRate === 0 || !soundEnabled) {
          if (beepAnimationFrameRef.current) {
            cancelAnimationFrame(beepAnimationFrameRef.current);
            beepAnimationFrameRef.current = null;
          }
          return;
        }

        const beepLoop = () => {
          const now = Date.now();
          const timeSinceLastBeat = now - lastBeepTimeRef.current;
          const beatInterval = 60000 / heartRate;
          
          if (timeSinceLastBeat >= beatInterval) {
            playBeep();
          }
          
          beepAnimationFrameRef.current = requestAnimationFrame(beepLoop);
        };

        beepLoop();

        return () => {
          if (beepAnimationFrameRef.current) {
            cancelAnimationFrame(beepAnimationFrameRef.current);
          }
        };
      }, [heartRate, connected, soundEnabled]);

      const connectToDevice = async () => {
        try {
          if (!navigator.bluetooth) {
            alert('Web Bluetooth wird nicht unterstützt! Bitte Chrome oder Edge verwenden.');
            return;
          }

          const device = await navigator.bluetooth.requestDevice({
            filters: [{ services: ['heart_rate'] }],
            optionalServices: ['heart_rate']
          });

          deviceRef.current = device;
          
          device.addEventListener('gattserverdisconnected', () => {
            setConnected(false);
            setHeartRate(0);
            setHistory([]);
            trailPointsRef.current = [];
          });

          const server = await device.gatt.connect();
          const service = await server.getPrimaryService('heart_rate');
          const characteristic = await service.getCharacteristic('heart_rate_measurement');
          
          characteristicRef.current = characteristic;
          
          await characteristic.startNotifications();
          characteristic.addEventListener('characteristicvaluechanged', handleHeartRateChange);
          
          setConnected(true);
          lastBeepTimeRef.current = Date.now();
        } catch (error) {
          console.error('Verbindungsfehler:', error);
          alert('Verbindung fehlgeschlagen: ' + error.message);
        }
      };

      const handleHeartRateChange = (event) => {
        const value = event.target.value;
        const flags = value.getUint8(0);
        let hr;
        
        if ((flags & 0x01) === 0) {
          hr = value.getUint8(1);
        } else {
          hr = value.getUint16(1, true);
        }
        
        setHeartRate(hr);
        
        setHistory(prev => {
          // KEINE Begrenzung mehr! Alle Werte über die gesamte Session
          const newHistory = [...prev, hr];
          const sum = newHistory.reduce((a, b) => a + b, 0);
          const avg = Math.round(sum / newHistory.length);
          const min = Math.min(...newHistory);
          const max = Math.max(...newHistory);
          
          setAvgHR(avg);
          setMinHR(min);
          setMaxHR(max);
          
          return newHistory;
        });
      };

      const getPulseHeight = (timeSinceLastBeat, beatInterval) => {
        if (beatInterval === 0) return 0;
        
        const pulseDuration = 80;
        
        if (timeSinceLastBeat > pulseDuration) return 0;
        
        const phase = timeSinceLastBeat / pulseDuration;
        
        if (phase < 0.1) {
          const t = phase / 0.1;
          return -0.2 * Math.sin(t * Math.PI);
        } else if (phase < 0.5) {
          const t = (phase - 0.1) / 0.4;
          return Math.sin(t * Math.PI) * 1.2;
        } else if (phase < 0.75) {
          const t = (phase - 0.5) / 0.25;
          return -0.3 * Math.sin(t * Math.PI);
        } else if (phase < 1.0) {
          const t = (phase - 0.75) / 0.25;
          return 0.15 * Math.sin(t * Math.PI);
        } else {
          return 0;
        }
      };

      const getHRZoneColor = (hr) => {
        if (hr <= 102) {
          return { r: 200, g: 200, b: 200 }; // Weiß/Grau
        } else if (hr <= 119) {
          return { r: 59, g: 130, b: 246 }; // Blau
        } else if (hr <= 137) {
          return { r: 34, g: 197, b: 94 }; // Grün
        } else {
          return { r: 239, g: 68, b: 68 }; // Rot
        }
      };

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerY = height / 2;

        const animate = () => {
          const gradient = ctx.createLinearGradient(0, 0, 0, height);
          gradient.addColorStop(0, '#0a0e1a');
          gradient.addColorStop(1, '#0f1419');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, width, height);

          ctx.strokeStyle = 'rgba(100, 150, 255, 0.08)';
          ctx.lineWidth = 0.5;
          
          for (let x = 0; x < width; x += 40) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
          }
          
          for (let y = 0; y < height; y += 40) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
          }

          ctx.strokeStyle = 'rgba(100, 150, 255, 0.15)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(0, centerY);
          ctx.lineTo(width, centerY);
          ctx.stroke();

          const baseScrollSpeed = 8;
          const scrollSpeed = heartRate > 0 ? baseScrollSpeed * (60 / heartRate) : baseScrollSpeed;
          
          scrollXRef.current += scrollSpeed;
          
          if (scrollXRef.current > width) {
            scrollXRef.current = 0;
            trailPointsRef.current = [];
          }

          const now = Date.now();
          const timeSinceLastBeat = now - lastBeepTimeRef.current;
          const beatInterval = heartRate > 0 ? (60000 / heartRate) : 0;
          
          const pulseHeight = getPulseHeight(timeSinceLastBeat, beatInterval);
          const y = centerY - pulseHeight * 150;

          trailPointsRef.current.push({ x: scrollXRef.current, y: y });
          
          const maxTrailLength = Math.floor(width * 0.95);
          while (trailPointsRef.current.length > maxTrailLength) {
            trailPointsRef.current.shift();
          }

          const color = getHRZoneColor(heartRate);

          if (trailPointsRef.current.length > 1) {
            for (let i = 0; i < trailPointsRef.current.length - 1; i++) {
              const point = trailPointsRef.current[i];
              const nextPoint = trailPointsRef.current[i + 1];
              
              const distanceFromCurrent = scrollXRef.current - point.x;
              if (distanceFromCurrent < 0) {
                continue;
              }
              
              const maxDistance = width * 0.95;
              const fadeStart = 0.7;
              let opacity;
              if (distanceFromCurrent / maxDistance < fadeStart) {
                opacity = 1;
              } else {
                const fadeProgress = (distanceFromCurrent / maxDistance - fadeStart) / (1 - fadeStart);
                opacity = Math.max(0, 1 - fadeProgress);
              }
              
              ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${opacity * 0.3})`;
              ctx.lineWidth = 8;
              ctx.shadowBlur = 20;
              ctx.shadowColor = `rgba(${color.r}, ${color.g}, ${color.b}, ${opacity * 0.5})`;
              
              ctx.beginPath();
              ctx.moveTo(point.x, point.y);
              ctx.lineTo(nextPoint.x, nextPoint.y);
              ctx.stroke();
              
              ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${opacity})`;
              ctx.lineWidth = 4;
              ctx.shadowBlur = 15;
              ctx.shadowColor = `rgba(${color.r}, ${color.g}, ${color.b}, ${opacity})`;
              
              ctx.beginPath();
              ctx.moveTo(point.x, point.y);
              ctx.lineTo(nextPoint.x, nextPoint.y);
              ctx.stroke();
            }
          }

          ctx.shadowBlur = 30;
          ctx.shadowColor = `rgba(${color.r}, ${color.g}, ${color.b}, 1)`;
          ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 1)`;
          
          ctx.beginPath();
          ctx.arc(scrollXRef.current, y, 8, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.shadowBlur = 20;
          const lighterColor = {
            r: Math.min(255, color.r + 60),
            g: Math.min(255, color.g + 60),
            b: Math.min(255, color.b + 60)
          };
          ctx.fillStyle = `rgba(${lighterColor.r}, ${lighterColor.g}, ${lighterColor.b}, 1)`;
          ctx.beginPath();
          ctx.arc(scrollXRef.current, y, 4, 0, Math.PI * 2);
          ctx.fill();

          animationRef.current = requestAnimationFrame(animate);
        };

        animate();

        return () => {
          if (animationRef.current) {
            cancelAnimationFrame(animationRef.current);
          }
        };
      }, [heartRate, connected]);

      const disconnect = () => {
        if (beepAnimationFrameRef.current) {
          cancelAnimationFrame(beepAnimationFrameRef.current);
        }
        
        if (characteristicRef.current) {
          try {
            characteristicRef.current.stopNotifications();
          } catch (e) {
            console.error('Stop notifications error:', e);
          }
        }
        
        if (deviceRef.current && deviceRef.current.gatt.connected) {
          deviceRef.current.gatt.disconnect();
        }
        
        setConnected(false);
        setHeartRate(0);
        setHistory([]);
        setAvgHR(0);
        setMinHR(0);
        setMaxHR(0);
        trailPointsRef.current = [];
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-white p-2 flex flex-col">
          <div className="flex gap-2 mb-2">
            <button
              onClick={() => setSoundEnabled(!soundEnabled)}
              className="flex-1 flex items-center justify-center gap-2 bg-slate-800/50 backdrop-blur-sm border border-slate-700/50 px-3 py-2 rounded-lg active:scale-95 transition-transform shadow-lg"
            >
              {soundEnabled ? (
                <Volume2 className="w-4 h-4 text-blue-400" />
              ) : (
                <VolumeX className="w-4 h-4 text-slate-500" />
              )}
              <span className="text-xs font-medium">{soundEnabled ? "Sound" : "Mute"}</span>
            </button>
            
            {!connected ? (
              <button
                onClick={connectToDevice}
                className="flex-1 flex items-center justify-center gap-2 bg-blue-600 hover:bg-blue-700 px-3 py-2 rounded-lg active:scale-95 transition-all shadow-lg shadow-blue-500/30"
              >
                <Bluetooth className="w-4 h-4" />
                <span className="text-xs font-semibold">Connect</span>
              </button>
            ) : (
              <button
                onClick={disconnect}
                className="flex-1 flex items-center justify-center gap-2 bg-red-600 hover:bg-red-700 px-3 py-2 rounded-lg active:scale-95 transition-all shadow-lg shadow-red-500/30"
              >
                <span className="text-xs font-semibold">Disconnect</span>
              </button>
            )}
          </div>

          <div className="grid grid-cols-4 gap-2 mb-2">
            <div className="bg-gradient-to-br from-slate-800/60 to-slate-900/60 backdrop-blur-sm border border-slate-700/50 rounded-lg p-2 text-center shadow-lg">
              <div className="text-xs text-slate-400 mb-1">LIVE</div>
              <div className="text-xl font-bold text-green-400">{heartRate || '--'}</div>
            </div>
            <div className="bg-gradient-to-br from-slate-800/60 to-slate-900/60 backdrop-blur-sm border border-slate-700/50 rounded-lg p-2 text-center shadow-lg">
              <div className="text-xs text-slate-400 mb-1">AVG</div>
              <div className="text-xl font-bold text-blue-400">{avgHR || '--'}</div>
            </div>
            <div className="bg-gradient-to-br from-slate-800/60 to-slate-900/60 backdrop-blur-sm border border-slate-700/50 rounded-lg p-2 text-center shadow-lg">
              <div className="text-xs text-slate-400 mb-1">MIN</div>
              <div className="text-xl font-bold text-cyan-400">{minHR || '--'}</div>
            </div>
            <div className="bg-gradient-to-br from-slate-800/60 to-slate-900/60 backdrop-blur-sm border border-slate-700/50 rounded-lg p-2 text-center shadow-lg">
              <div className="text-xs text-slate-400 mb-1">MAX</div>
              <div className="text-xl font-bold text-purple-400">{maxHR || '--'}</div>
            </div>
          </div>

          <div className="bg-gradient-to-br from-slate-800/80 to-slate-900/80 backdrop-blur-sm border border-slate-700/50 rounded-lg overflow-hidden shadow-2xl flex-1">
            <canvas
              ref={canvasRef}
              width={1600}
              height={600}
              className="w-full h-full"
            />
          </div>
        </div>
      );
    }

    ReactDOM.render(<HeartRateMonitor />, document.getElementById('root'));
  </script>
</body>
</html>
